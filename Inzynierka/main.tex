\documentclass[12pt, eng, twoside, openany, final]{mgr}
% \documentclass[eng, printmode]{mgr}

\include{preambula}
% \include{bibliografia}


% re-definiowane polecenie w celu przechowywania nazwiska autora, jego brak powoduje ostrzezenie (Warning) podczas przetwarzania.
\author{Piotr Szczpański} 

% re-definiowane polecenie w celu przechowywania polskiego tytułu pracy magisterskiej, jego brak powoduje ostrzezenie (Warning) podczas przetwarzania.
\title{Moduł sterownika oświetlenia LED} 


% polecenie zdefiniowane w celu przechowywania angielskiego tytułu pracy magisterskiej, jego brak powoduje ostrzezenie (Warning) podczas przetwarzania.
\engtitle{LED lighting controller module} 


% polecenie zdefiniowane w celu przechowywania danych osobowych prowadzacego prace, jego brak powoduje ostrzezenie (Warning) podczas przetwarzania.
\supervisor{dr inż. Antoni Izworski} 

% polecenie zdefiniowane w celu przechowywania danych osobowych opiekuna pracy. W przypadku gdy jest to ta sama osoba co \supervisor, nie nalezy uzywac tego polecenia. Jego brak usunie ze strony tytułowej zbedna informacje.
% \guardian{tytuł, Imie Nazwisko, jednostka} 


% polecenie zdefiniowane w celu przechowywania nazwy kierunku studiów, jego brak powoduje ostrzezenie (Warning) podczas przetwarzania.
\field{Automatyka i Robotyka (AIR)} 


% polecenie zdefiniowane w celu przechowywania nazwy specjalnosci studiów, jego brak powoduje ostrzezenie (Warning) podczas przetwarzania.
\specialisation{Robotyka (ARR)} 

% re-definiowane polecenie w celu przechowywania roku. Standardowo u dołu strony tytułowej wstawiany jest biezacy rok, uzycie tego polecenia pozwala wstawic dowolny rok.
\date{2018}
\usepackage{fancyhdr}

\begin{document}
\maketitle
\tableofcontents
\listoffigures
\newpage

\pagestyle{fancy}
\fancyhead{} 
\fancyfoot{} 
\lhead{Politechnika Wrocławska Wydział Elektroniki}
\rfoot{\thepage}
\lfoot{Szczepański P, Moduł sterownika oświetlenia LED}


\chapter{Wstęp}
\thispagestyle{fancy}
    \section{Wprowadzenie}
    W dzisejszczych czasach oświetlenie w naszych domach opórcz funkcji czysto praktycznej, ma również służyć jako dekoracja i stanowić integralną część wystroju. \\*
    Oświetlenie LED stanowi znaczącą część rynku elektroniki konsumenckiej i w ciągu kilkunastu lat wyparła prawie całkowicie z użytku codziennego wolframowe żarówki i lampy wyładowcze (potocznie zwane świetlówkami). Popularność technologii LED jest spowodowana głównie atrakcyjnymi cenami produktów i znacząco większą sprawnością elektryczną oraz co za tym idzie niższym zużyciem energii elektrycznej.
    
    \section{Cel i zakres pracy}
    Celem pracy jest stworzenie opisu powstawania, dokumentacji użytkownika i dokumentacji technicznej nowoczesnego sterownika oświetlenia LED opartego na platformie~ mikrokontrolerowej.
    
    Zakres pracy obejmuje opracowanie materiałów produkcyjnych, oprogramowania oraz fizycznego modelu. W szczególności zakres pracy obejmuje: 
    \begin{itemize}
        \item zaprojektowanie elektroniki, 
        \item zbudowanie modułu sterownika oświetlenia,
        \item stworzenie opiu i objaśnienia wykorzystanych technologii,
        \item wytworzenie oprogramowania oraz jego opisu funkcjonalnego,
        \item opracowanie dokumentacji technicznej modułu,
        \item opracowanie instrukcji obsługi modułu oraz dokumentacji dla użytkownika końcowego.
    \end{itemize}
%
\chapter{Założenia projektowe}
\thispagestyle{fancy}  
    Tworzony moduł będzie oferował użytkownikowi możliwość sterowania kolorami i jasnością trójkolorowego paska ledowego oraz sterwoanie dwoma wyjściami przekaźnikowymi. Użytkownik będzie komunikował się z modułem przez czterocalowy dotykowy wyświetlacz. Interfejs będzie udostępniał możliwość ręcznej zmiany stanów podłączonego oświetlenia, programowania własnych sekwencji zmiany kolorów paska LED i stanów wyjść przekaźnikowych oraz czasowego wywoływania zapisanych scen oświetleniowych.\\*
    Gotowy moduł sterowonika oświetlenia LED musi spełniać kryteria jakościowe, w szczególności:
    \begin{itemize}
        \item częstoliwość odświeżania generowango sygnału PWM sterującego pasek ledowy musi być na tyle wysoka, aby nie można było zaobserować migotania,
        
        \item graficzny interfejs użytkownika powinien być przejżysty, intuicyjny w obsłudze oraz na tyle responsywny, żeby
        obsługa modułu była komfortowa,
        
        \item moduł musi działać w ciągłości, tzn. konfiguracja wbudowanego systemu operacyjnego musi zabezpieczać sytuacje
        krytycznych błędów czasu działania, między innymi takich jak: desynchronizacja systemowego zegara, wyłączenie aplikacji interfejsu graficznego
    \end{itemize}
%
\chapter{Opis wykorzystanych technologii}
\thispagestyle{fancy}
    \section{Raspberry Pi}
    Raspberry Pi jest serią jednopłytkowych komputerów opartych na rdzeniach ARM. Pod nazwą Raspberry Pi kryje się również olbżymia społeczność rozwijająca oprogomowanie, tworząca biblioteki i materiały edukacyjne.
    W projekcie wykorzystano model \emph{Raspberry Pi Zero W V1.3} oparty na procesorze  \emph{Broadcom BCM2835 ARM11}. Moduł wyposażony jest m.in. w 512MB pamięci RAM, moduł WiFi, moduł Bluetooth, port miniHDMI. Z uwagi na  duże możliwości techniczne oraz niską cenę, modułu ten jest powszechnie wykorzystywany przy prototypowaniu urządzeń elektronicznych IoT.
    \textcolor{red}{Linux}
    
    \section{Język C++}
    Język C++ powstawł w roku 1979 stworzony przez Bjarne Stroustrup'a jako rozszerzenie języka, od tego czasu C++ doczekał się kilku standardów i od 2011 roku co 3 lata wydawana jest jego nowa wersja. C++ osiągną olbrzymią popularność dzięki swojej uniwersalności. W komercjnych zastosowaniach przy tworzeniu oprogramowania na wbudowane systemy wbudowana często wypiera używanie czystego języka~C. C++ pozwala na tworzenie kodu zarówno nisko jak i wyskopoziomowego. Kod może być zarówno zorientowany obiektowo jak również czysto procedulany. 
     \textcolor{red}{enkapsulacja
    polimorfizm
    biblioteki
    boost}
    
    
    \newpage
    \section{Biblioteka QT i QML}
    QT jest zestawem bibliotek, których głównym celem jest tworzenie interfejsów graficznych aplikacji komputerowych. Ponadto QT dostarcza wiele narzędzi programistycznych pomagających rozwijać oprogramowanie. Oprócz zastosowań komputerowych QT daje możliwości tworzenia aplikacji na urządzenia wbudowane i jest powszechnie używane przez takie firmy jak: LG, Mercedes-Benz.
    \textcolor{red}{qml }
 
%
\chapter{Dokumentacja użytkownika}
\thispagestyle{fancy}
    \section{Podłączanie zasilania i urządzeń wykonawczych}
    Moduł zasilany jest napięciem 12V i nie posiada zabezpieczenia przeciw odwrotnej polaryzacji zasilania. więc błędne podłączenie zasilacza może uszkodzić sterownik. \\*
    Maksymalna moc oświelenia podłączonego do wyjść wynosi:
    \begin{itemize}
        \item sumarycznie dla wyjść sterownika paska led : \textbf{00}W, czyli dla każdego kanału \textbf{00}W,
        \item dla każdego z wyjść przekaźnikowych : \textbf{100} W
    \end{itemize}
    Instalator musi pamiętać, że podłączone obciążenie nie może przekraczać maksymalnej mocy zasilacza ponadto maksymalny prąd zasilacz powinien wynosić przynajmnej 750mA, więcej niż potrzebuje tego obicążenie, gdyż należy doliczyć zapotrzebowanie Raspberry Pi z wyświetlaczem. Podane \textbf{750}mA jest wartością bezpieczną i nie znaczy to, że moduł pobiera w trakcie swojego działania taki prąd. \\*
    Zasilacz należy podłączyć do złącza \emph{J5}, wyjścia przkaźnikowe są oznaczone symbolami \emph{J3}, \emph{J4}, a sterownik paska ledowego \emph{J1J2}. Sposób podłączenie paska led jest oznaczony bezpośrednio na płytce. 
        \begin{figure}[H]
        \begin{center}
            \includegraphics[width=0.65\textwidth]{podlaczone.jpg}
            \caption{Przykład podłączenia zasilania, paska led oraz żarówki led}
        \end{center}
        \end{figure}
    \newpage
    
    \section{Opis interfejsu graficznego}
    Interfejs graficzny zbudownany jest jako seria widoków, aby aktywować kolejny widok należy horyzontalnie przesunąć rysikiem po wyświetlaczu dotykowym, zgodnie z rządanym kierunkiem zmiany widoku. Takie rozwiązanie jest intuicyjne, gdyż dokładnie w takim sposób obsługuje się interfejsy graficzne w telefonach komórkowych (smartphonach), więc jest to zachowanie do którego przeciętny użytkownik jest przyzwyczajony.
    Widokiem startowym jest widok kontroli ręcznej wyjść modułu.
        \begin{figure}[H]
        \begin{center}
            \includegraphics[width=0.5\textwidth]{ui_live.jpg}
            \caption{Zdjęcie ekranu z interfejsem graficznym}
        \end{center}
        \end{figure}
    
    Położenie aktywnego widoku jest prezentowane w dolnej części interfejsu. Ciemniejsza kropka oznacza aktywny region, pozostałe pokazują dostępne regiony.
        \begin{figure}[H]
        \begin{center}
            \includegraphics[width=0.25\textwidth]{ui_pageind.jpg}
            \caption{Wskaźnik widoków}
        \end{center}
        \end{figure}
    \newpage
    
    \section{Opis funkcji}
        \subsection{Tworzenie scen}
        Tworzenie scen odbywa się przez zapisanie do wybranego slotu aktualnych ustawień sterownika. Sterownik udostępnia 9 slotów na sceny.
        Każda ze scen przechowuje dane o ustawieniach wyjść paska ledowego oraz stanie wyjść przekaźnikowych. 

            \begin{figure}[H]
            \begin{center}
                \includegraphics[width=0.45\textwidth]{ui_manualTab.jpg}
                \caption{Widok ustawień manualnych}
            \end{center}
            \end{figure}
            Tworzenie scen należy rozpocząć od ręcznego ustawienia rządanych stanów wyjść, poprzez przesuwanie rysikiem po ekranie i obserwację podłączonego paska ledowego. Aby zapisać obecne ustawienia w pamięci sterownika należy wybrać z pola Rys \ref{fig:box} miejsce w pamięci pod którym ma dostępna być scena. Jeśli w danej scenie występują zapisane dane to zostaną one nadpisane tą czynnością.
            
            \begin{figure}[!h]
        	\centering
        	\begin{minipage}[t]{3cm}
        		\centering
        		\includegraphics[scale=0.4]{ui_box.jpg}
        		\caption{Pole wyboru scen} \label{fig:box} 
        	\end{minipage}
        	\hspace{3cm}
        	\begin{minipage}[t]{5cm}
        		\centering
        		\includegraphics[scale=0.4]{ui_sceneTAB.jpg}
        		\caption{Widok scen} \label{fig:scene} 
        	\end{minipage}
        \end{figure}
            
        Drugi widok (licząc od lewej strony) pozwala użytkownikowi wybrać z zapisanych scen. Jak można zaobserować na Rys \ref{fig:scene}, aktywne są wyłącznie przyciski, w których sceny zawierają dane.
        \newpage 
        
        \subsection{Tworzenie zdarzeń aktywownych czasowych}
        Funkcja ta pozwala na stworzenie dwóch alarmów, które o zadanym czasie będą aktywowały wybraną funkcję. 
            \begin{figure}[H]
            \begin{center}
                \includegraphics[width=0.5\textwidth]{ui_time.jpg}
                \caption{Widok alarmów czasowych}
            \end{center}
            \end{figure}
            
        W lewej części widoku należy wybrać godzinę aktywacji, w śrdokowej częsci wybiera się funkcję, która ma zostać wywołana. Przełącznik po prawej stronie aktywuje alarm i w po jego aktywacji, tak jak widać na dolnym alarmie, kontrolki stają się nieedytowalne. Alarmy mają priorytet w wyłoaniu nad innymi funkcjami, więc należy pamiętać o ich ustawieniu.
        
        \subsection{Aktywacja animacji}
        Funkcja ta pozwoli włączyć animacje paska led, można wybrać z 10 gotowych, wcześniej zaprogramowanych. Obecna wersja oprogramowania nie pozwal użytkownikowi tworzyć własnych sekwencji kolorów. Użytkownik przy każdej sekwencji może wybrać szybkość jej wykonywanie w tym celu służy suwak znajdujący się na środku widoku.
            \begin{figure}[H]
            \begin{center}
                \includegraphics[width=0.5\textwidth]{ui_animation.jpg}
                \caption{Widok ustawień animacji}
            \end{center}
            \end{figure}
        
        \subsection{Sterowanie stanami}
        Na ostatniej pozycji w przesuwalnym menu, znadjuje się widok służący włączaniu i wyłączaniu wyjść. Ma on najwyższy priorytet, więc w momencie aktywacji alarmu lub sterowania ręcznego, gdy wyjście będzie wyłączone w tym widoku, inne operacje będą ignorowane. W przypadku przłącznika stanu dla paska ledowego, gdy wszystkie jego ustawienia będą równe zero, a użytkownik użyje przełącznika, to będzie on nadal wyłączony. Przełącznik ten służy do wyłączania wybranej sceny lub animacji. Nie powoduje on jednak zatrzymania animacji.
            \begin{figure}[H]
            \begin{center}
                \includegraphics[width=0.5\textwidth]{ui_global.jpg}
                \caption{Widok przełączników wyjść} \label{fig:switches}
            \end{center}
            \end{figure}
    
    
    \newpage

\chapter{Dokumentacja serwisowa}
\thispagestyle{fancy}
    \section{Typowe wykorzystanie}
    Przeznaczeniem modułu jest wykorzystanie w pomieszczeniu użytkowym, do sterowania intensywnością świecenia poszczególnych kolorów paska ledowego oraz do przełączania dwóch dwunastowoltowych wyjść przekaźnikowych. Wyjścia przekaźnikowe zostały umieszczone w projekcie aby pozwolić użytkownikowi podłączyć i sterować np.: stanem jednokolorowego paska LED, stanem żarówki LED lub zewnętrznym przekaźnikiem bądź stycznikiem. Maksymalne parametry elektryczne określone są w sekcji \emph{5.2.1 Elektornika wykonawcza}.
    
    
    \section{Budowa modułu}
    Sterownik składa się z zaprojektowanej płytki z elektroniką wykonawczą i stabilizatorem napięcia, połączonej wielożyłowym kablem z modułem \emph{Raspberry Pi}, do którego, za pomocą listwy goldpin, podłączony jest wyświetlacz dotykowy.
        \begin{figure}[H]
        \begin{center}
            \includegraphics[width=0.45\textwidth]{diagram.jpg}
            \caption{Schemat ideowy modułu}
        \end{center}
        \end{figure}
        
       
        \begin{figure}[!h]
        	\centering
        	\begin{minipage}[t]{5cm}
        		\centering
        		\includegraphics[scale=0.1]{rpi_goldpin.jpg}
        		\caption{Raspberry Pi z przylutowanymi złączami goldpin} \label{fig:rpi1} 
        	\end{minipage}
        	\hspace{3cm}
        	\begin{minipage}[t]{5cm}
        		\centering
        		\includegraphics[scale=0.1]{rpi_lcd.jpg}
        		\caption{Połączenie Raspberry Pi z wyswietlaczem dotykowym} \label{fig:rpi_lcd} 
        	\end{minipage}
        \end{figure}
        Dzięki takiej budowie elementy wydzielające ciepło, takie jak tranzysory i procesor, mogą być od siebie oddalone. 
        \begin{figure}[H]
            \begin{center}
            \includegraphics[width=0.6\textwidth]{poloczona_zoom.jpg}
            \caption{Moduł wykonawczy połączony z Rapsberry Pi}
            \end{center}
        \end{figure}
        
        \newpage
        \subsection{Elektronika wykonawcza}
            \subsubsection{Sterownik paska LED}
                Protoypowanie modułu rozpoczęto od budowy sterownika paska ledowego, który sterowany był z prostego 8-bitowego mikrokontorlera \emph{Atmega 168P}. 
                Sterownik składa się z trzech identycznych kanałów, osobnego dla każdego koloru paska. 
                \begin{figure}[H]
                \begin{center}
                    \includegraphics[width=0.45\textwidth]{sterownik.png}
                    \caption{Schemat trzykanałowego sterownika paska LED}
                \end{center}
                \end{figure}
                Elementem wykonawczym są tranzystory MOSFET (ang. Metal-Oxide Semiconductor Field-Effect Transistor), oznaczone na schemacie symbolami \emph{Q1}, \emph{Q2}, \emph{Q3}. Po podaniu między złącza bramka(ang. gate) i źródło(ang. source), określonego w nocie katalogowej, napięcia, tranzysor zaczyna przewodzić między złączami dren(ang. drain)-źródło. Należy pamiętać, żę między drenem, a źródłem występuje rezystancja określona w nocie katalogowej symbolem Rds(on). Jest to ważny parametr, ponieważ ma on wpływ na ilość energii, która zostanie wytracona w formie ciepła, a co za tym idzie maksymalny prąd jaki tranzysor może przewodzić bez przegrzewania~się. \\*
                \textcolor{red}{wyprowadzenie maksymalnej mocy, wykres temperatury od obciążenia i wypełnienia, }
        
                \newpage
        
            \subsubsection{Wyjścia przekaźnikowe}
            Moduł wyposażono również w dwa wyjścia przekaźnikowe pozwalające użytkownikowi na sterowanie stanem m.in. takich peryferiów jak: jednokolorowy pasek ledowy, żarówka led. W projekcie wykorzystano przekaźniki \emph{BLOW JQC-3F 12VDC}, dopuszają one przełączanie 10A prądu stałego przy 12V.
            Moc cewki wybranych przekaźników wynosi 0.45W, więc w celu ich sterowania należało użyć tranzystor MOSFET. Niezbędnym elementem obwodu sterownikia trnazystorowego przekaźników jest dioda, \emph{D3}, \emph{D4}, zabezpieczająca tranzystor przed energią znajdującą się w cewce przekaźnika, który zostaje z niej wydalona pod wpływem zapadania się pola magnetycznego.
                \begin{figure}[H]
                \begin{center}
                    \includegraphics[width=0.75\textwidth]{przekazniki.png}
                    \caption{Schemat wyjść przekaźnikowych}
                \end{center}
                \end{figure}
        \subsection{Przetwornica napięcia}
        Na płytce znajudje się również przetwornica napięcia, która służy zasileniu Raspberry Pi Zero. Zdecydowano się na wykorzystanie \emph{ON Semiconductor MC34063A} z uwagi na dużą dostępność, niską cenę oraz łatwość użycia. Moduły MC34063 pracują w zakresie napięcia wejściowego od 3V do 40V i mogą być skonfigurowane w trybie obniżania, podwyższania lub odwracania napięcia. Maksymalny prąd wyjściowy to 1.5A, jest to wartość przekraczająca potrzeby przy zasilaniu większości mikroprocesorów. Sterowanie parametrami układu DC-DC odbywa się przez dobór wartości elementów pasywnych. Nota katalogowa układu dostarcza potrzebne w wzory potrzebne do obliczenia wartości elementów.
                \begin{figure}[H]
                \begin{center}
                    \includegraphics[width=0.75\textwidth]{psu.png}
                    \caption{Schemat przetwornicy napięć}
                \end{center}
                \end{figure}
                
        Parametry wyjściowe układu wynoszą:
        \begin{itemize}
            \item Napięcie wejściowe : 12V
            \item Napięcie wyjściowe : 5V
            \item Częstotliwość      :  \textcolor{red}{00}Hz 
            \item Wahania napięcia wyjściowego :  \textcolor{red}{00}Vpp 
        \end{itemize}
                
        \subsection{Elektronika dodatkowa}
        Na płytce umieszczono również elementy służące wyłącznie weryfikacji poprawności działania układu.
        
        \subsubsection{Przełącznik trybów pracy}
            \begin{figure}[H]
            \begin{center}
                \includegraphics[width=0.4\textwidth]{przelacznik.jpg}
                \caption{Schemat przełącznika trybów pracy}
            \end{center}
            \end{figure}
        W celach zmiany trybów diagnostycznych na płytce znajduje się potrójny przełącznik suwakowy. Z uwagi na 3.3V poziom logiczny Raspberry Pi i fakt, że na płytce znajduje się jednynie przetwornica napięcia o 5-cio V wyjściu należało stowrzyć dzielnik napięciowy tworzony z rezystorów R17 i R18. Rezystory R19, R20, R21 są rezystorami podciągającymi.  
        \subsubsection{Diody sygnalizujące stan pracy}
            \begin{figure}[H]
            \begin{center}
                \includegraphics[width=0.4\textwidth]{wskaznik.jpg}
                \caption{Schemat diod sygnalizacyjnych} 
            \end{center}
            \end{figure}
        Moduł posiada 3 diody sygnalizacyjne służące do informowania użytkownika o błędach lub mogące być wykorzystane przy sprawdzaniu modułu. Rezystory R12, R15, R16 dobrano tak aby intesywność świecenia diod nie sprawawiała dyskomfortu serwisantowi badającemu sterownik.
        
        \subsection{Wyświetlacz dotykowy}
            \begin{figure}[H]
            \begin{center}
                \includegraphics[width=0.6\textwidth]{wyswietlacz.jpg}
                \caption{Wyświetlacz dotykowy używany w module} 
            \end{center}
            \end{figure}
            W projekcie zdecydowano się na użycie gotowego modułu wyświetlacza dotykowego 
            \emph{Waveshare}. Jego rozmiar to 95 x 61 mm i posiada rozdzielczość 320x480 pikseli. Z uwagi na te dwie własności, graficzny interfejs użytkownika został zaprojektowany tak aby wyświelane informacje były czytelene. Komunokacja z Raspberry Pi odbywa się przez SPI. Produkt jest dedykowany do użytku z Raspberry Pi. Dokładniejsze przedstawienie sposobu działania jest niemożliwe, ponieważ produkt jest chroniony patentem i producent po za podstawową instrukcją obsługi i steronikami nie udostępnia dokumentacji technicznej.

        
        \subsection{Płytka drukowana}
            Po zakończonym etapie prototypowania poszczególnych partii, elementy te zostały połączone w jeden schemat, na podstawie którego zaprojektowano płytkę drukowaną (PCB). 
            Płytka ma wymiary 90x62mm, jest dwustronna, dzięki temu udało się zmniejszyć jej docelowy rozmiar.
            
    \section{Instrukcja montażu}
    Montaż układu powinno rozpocząć się od wizualnego sprawdzenia poprawności wykonania płytki drukowanej, ważnym jest sprawdzenie czy wszystkie punkty lutownicze są poprawnie pokryte i czy ścieżki nie wyglądają na uszkodzone, np. w transporcie.
    Pierwszym krokiem jest przylutowaie przetwornicy napięć, ponieważ jest to najmniejszy element i jej montaż może być później utrudniony przez sąsiadujące elementy. Dalej należy przylutować transoptory \emph{A1}, \emph{A2}, \emph{A3}.  Następnie w dowolnej kolejności można przylutować: rezystory \emph{R1} do \emph{R21}, kondensatory \emph{C0}, \emph{Ct}, \emph{C2}, diody \emph{D1}, \emph{D3}, \emph{D4}, tranzystory \emph{Q1}, \emph{Q2}, \emph{Q3}, \emph{Q5}, \emph{Q6}, diody led \emph{LED1}, \emph{LED2}, \emph{LED3}. Po wykonaniu tych czynności należy przylutować złącze \emph{JP1}, przełącznik suwakowy \emph{SW1}, złącza ARK \emph{J1} - \emph{J5}. Ostatnimi elementami na górnej warstwie są przekaźniki \emph{K2}, \emph{K3}. Na dolej warstwie płytki powinna znaleźć się cewka \emph{L1} i rezystor \emph{RSC}, tak~jak jest to widoczne na \ref{fig:pcb_dol}. \\*
    Złącza goldpin na Raspberry Pi powinne zostać polutowane tak aby piny od 27 do 40 były skierowane w kierunku przeciwnmy do mikroprocesora na płyce (patrz \ref{fig:rpi1}), pozostałe odwrotnie. 
            \begin{figure}[H]
            \begin{center}
                \includegraphics[width=0.5\textwidth]{dol.jpg}
                \caption{Dolna warstwa płytki} \label{fig:pcb_dol} 
            \end{center}
            \end{figure}
    Montaż wyświetlacza dotykowego do płytki Raspberry Pi odbywa się przez wsunięciego w złącze goldpin, poprawny instalacja widoczna jest na \ref{fig:rpi_lcd}. Komunikacja płytki sterującej z płytką wykonawczą odbywa się przez 16-sto żyłowy kabel, który od strony płytki wykonawczej powinnien być zakończony damski złączem 2x8 goldpin, a na drugim końcu złączem 2x7 oraz dwoma przewodami, które muszą zostać przylutowane do pinów 3 (5V) i 4 (GND) na Raspberry Pi. 

    \newpage
    \section{Sprawdzanie modułu}
            Płytka i opis znajdujący się na niej został zaprojektowany tak, aby w łatwy sposób można było sprawdzić poprawność działania modułu. 
            
            \subsection{Sprawdzanie poprawności działania samego modułu wykonawczego}
            Dolna strona PCB zawiera dwa rodzaje oznaczeń, które służą do sprawdzenie poprawności działania elektroniki płytki:
            \begin{itemize}
                \item oznaczaczenia \emph{G*} informujące do którego pinu mikroprosesora podłączone jest dany element modułu, ma to uławtić programowanie i sprawdzanie poprawności konfiguracji pryferiów,
                \item oznaczenia \emph{P*} będące punktami testowymi.
            \end{itemize}
               \begin{figure}[H]
                \begin{center}
                    \includegraphics[width=0.6\textwidth]{pcb_dol_zaz.png}
                    \caption{Punkty kontroli poprawności działania}
                \end{center}
                \end{figure}
            Na płytce znajduje się, również oznaczenie mówiące o poprawnych wartościach między punktami kontrolnymi \emph{P1} - \emph{P4} oraz napięcia, które należy podać między masą a punktami \emph{P5} - \emph{P6}.
            Sprawdzenie poprawności montażu elemtów prztwronicy napięcia, odbywa się przez pomiar napięcia między punktami P1 P2, napięcie to powinnow wynosić 5V z  \textcolor{red}{00} procentową dokładnością.
            Należy również sprawdzić wartość napięcia między punktami P3 P4, które powinno wynosić  \textcolor{red}{0000}.
            W celu sprawdzenia sterownika paska LED należy podać 12V kolejno między masą, punktami P5.1, P5.2, P5.3 i mierzyć napięcie na odpowiadających wyjściach sterownika. Moduł działa poprawnie jeśli napięcie na wyjściu każdego z kanałów będzie równe 12V.
            Sprawdzeie wyjść przekaźnikowych odbywa się przez podnie 3.3V, z punktu P4, na punkty P6.1 i P6.2.
            Przekaźnik w momencie przełączania wydaje wyraźny dźwięk (kliknięcie), więc jego brak w chwili podłączenia napięcia oznacza niepoprawne działanie. Kolejnym etapem weryfikacji jest zmierzenie napięcia na wyjściach przekaźnikowych przy zwartych P6.1 lub P6.2 z P4, powinno ono być równe 12V.
            \\* Opisane metody testowania nie wymagają podłączenie Raspberry Pi, ale wymagają podłączenie zasilania 12V. 
            
            \subsection{Sprawdzenie poprawności działania całości modułu}
                \begin{figure}[H]
                \begin{center}
                    \includegraphics[width=0.5\textwidth]{dip_zoom.jpg}
                    \caption{Przełącznik trybów i diody sygnalizacyjne}
                \end{center}
                \end{figure}
            Sterownik udostępnia 3 tryby serwisowe wybierane za pomocą przełącznika suwakowego.
            Oprogramowanie sterownika odczytuje wartości, wejść do których podłączony jest przełącznik, w momencie startu systemu, więc aby włączyć tryb serwisowy należy odłączyć zasilanie modułu, wybrać tryb i podłączyć zasilanie. Nie jest dozwolnoe przełączenie dwóch lub więcej przełączników, w takim przypadku system zignoruje te informacje i uruchomi moduł w trybie pracy normalnej. Przejście modułu w tryb serwisowy sygnalizowane jest ciągłym podświetleniem diody \emph{LED3}.
            
            Dostępne tryby:
            \begin{itemize}
                \item przełącznik w pozycji 1 - w trybie tym sterownik będzie włączał i wyłączał z odstępem 1 sekundy wyjścia modułu w kolejnośc : kanał czerwony, kanał zielony, kanał niebieski, wyjście przekaźnikowe 1, wyjście przekaźnikowe 2. Tryb ten pozwala sprawdzić poprawność działania elektroniki wyjściowej oraz podłączenia modułu Raspberry Pi.
                
                \item przełącznik w pozycji 2 - tryb służy do sprawdzenia poprawności działania wyświetlacza, w szczególności poprawności wyświelania kolorów, czasu odświeżania dokładności powierzchni dotykowej.
                Na ekranie wyświeli się licznik inkrementujący swoją wartość od 0 do 10000 co 200ms, napis "TEST" w 3 rozmiarach oraz tło aplikacji będzie zmieniało kolory z częstotliwością 500ms w kolejności: czerwony, zielony, niebieski, biały. Ponadto na ekranie widoczne będą 4 pola dotykowe, których naciśnięcie będzie aktywowało diodę \emph{LED2}, w przypadku wykrycia dotyku po za, którymś z tych pól załączona zostanie dioda \emph{LED1}. 
                
                \item przełącznik w pozycji 3 - tryb służący do kontroli obciążenia procesora systemu, zajętości RAM-u oraz temperatury na procesorze. Informacje te będą wyświetlane na ekranie. Ponadto zostanie wyświelony plik kontrolny z poprzedniego uruchomienia modułu.
            \end{itemize}
            
            Wyłączenie trybu serwisowego jest możliwe dopiero po odłączniu zasilania i ustawieniu przełącznika serisowego do konfiguracji pracy standardowej.
            Moduł ignoruje zmiany przełącznika suwakowego w czasie działania programów.
            
            \newpage
            
            \section{Dokumentacja oprogramowania}
            Kompletny zestaw wytworzonego oprogramowania modułu składa się z pięciu plików binarnych - jednego dla programu użytkownika, trzech dla każdego z trybów serwisowych, jednego służącego do konfiguracji peryferiów oraz ze skryptu Bash'owego wykorzystywanego przy starcie modułu.
            
                \subsection{Interfejs graficzny}
                Interfejs graficzny jest w całości napisany w języku QML korzystając z biblioteki QtQuick w wersji 2.6, za paletę kolorów interfejsu odpowiada biblioteka Material 2.0, kształ i zachowania elementów widoku zaczerpnięto z biblioteki Controls 2.0. 
                
                \subsubsection{Przykład połączenia klasy C++ z QML}
                Przykład demonstruje mechanizm łączenia klas C++ z kodem interfejsu graficznego w QML, z uwagi na zbyt dużą złożoność kodu w projekcie, posłużono się uproszczono wersję. Kod przykładu pokazuje obsługę przłącznika (Switch) takiego jak wykorzystany na Rys \ref{fig:switches}.
                    \begin{figure}[H]
                    \begin{center}
                        \includegraphics[width=0.65\textwidth]{code_class.jpg}
                    \end{center}
                    \end{figure}
                    Klasa UiManualData ma reagować na zmianę statnu przełącznika w sposób asynchroniczny, aby to osiągnąć należy skorzystać z modelu sygnałów i slotów z QT. Tworząc własny typ uzyskuje się to przez dziedzicznie po typie QObject oraz definicję makra Q\_OBJECT w sekcji prywantej klasy. W lini 9 znajduje się definicja slotu, który będzie wywoływany z objektu QML.
                    
                    \begin{figure}[H]
                    \begin{center}
                        \includegraphics[width=0.65\textwidth]{code_main.jpg}
                    \end{center}
                    \end{figure}
                    W celu udostępnienia klasy UiManualData w QML, należy ją zarejstrować, czynność ta odbywa się w linijce 8.
                    
                    \begin{figure}[H]
                    \begin{center}
                        \includegraphics[width=0.65\textwidth]{code_qml.jpg}
                    \end{center}
                    \end{figure}
                    W pliku .qml należy zaimportować klasę, linia 1, trzeba pamiętać o numerze wersji z jakim zarejstrowało się dany typ. Następnie trzeba stworzyć obiekt tej klasy, linijki 4-6.
                    Po wykonaniu tych czynności można korzystać z interfejsu klasy. W sygnale \emph{onToggle} (sygnał wywoływany przy zmianie statnu przełącznika) obiektu Switch, występuje wywołanie metody klasy UiManualData.
                
                \newpage
                
                
                \subsection{Backend}
                Zaplecze oprogramowania zaprojektowano w formie warstw funkcjonalności. Podział ten wiadać na Rys \ref{fig:layers}. Dokumentowanie oprogramowania w taki sposób definiuje jedynie logiczny podział kodu oraz przepływ informacji i nie deaktualzuje się przy dodawaiu nowych funkcjonalności.  
                    \begin{figure}[H]
                    \begin{center}
                        \includegraphics[width=0.7\textwidth]{inz_diag.png}
                        \caption{Schemat warstwowy oprogramowania trybu normalnego~użytku} \label{fig:layers}
                    \end{center}
                    \end{figure}
                \subsubsection{Warstwa sygnałów UI}
                Warstwa sygnałów UI jest bezpośrednim połączeniem z interfejsem graficznym QML, wykorzystywane są tutaj takie mechanizmy jak ten przedstawiony w sekcji 5.5.1. Warstwa ta jest całkowicie przezroczysta - nie przechowywane są tutaj rzadne dane oraz nie ma w niej zaimplementowanej logiki systemu. Sprawdzane jest jedynie czy dane przychodzące z UI są poprawne.
                
                \subsubsection{Warstwa danych}
                Warstwa danych przechowuje dane wprowadzone przez użytkownika takie jak: konfiguracja scen i alarmów, obecny stan modułu, dane animacji.  
                
                \subsubsection{Warstwa logiki}
                Warstwa logiki jest prostą maszyną stanów, która podejmuje decyzje na podstawie sygnału z interfejsu użytkownika jak i z informacji o obecnym stanie urządzenia. Na przykład jeśli użytkownik ręcznie uruchomi animację i w trakcie jej wykonywania zostanie aktywowany alarm, zostanie zlecone przerwanie wykonywania animacji i wywołana będzie zadana funkcja alarmu.
                
                \subsubsection{Warstwa obsługi zadań}
                Warstwa obsługi zadań odpowiada za planowanie i wykonywanie czynności zadanych przez warstwę logiki, dane do poszczególnych zadań pobierane są bezpośrednio z warstwy danych.
                
                \subsubsection{Warstwa obsługi sprzętu}
                Warstwa obsługi sprzętu jest jednie abstrakcją do sprzętu urządzenia, wykonuje zlecone polecenia, nie podejmuje, żadnych decyzji, może jedynie zgłosić błąd wykonywania czynności.
                
                    \newpage
                \subsection{Obsługa sprzętu}
                Do obsługi sprzętu zdecydowano się użyć bibliotekę WiringPi, która jest udostępniana na zasadach \emph{GNU LGPL v.3 }. Biblioteka jest napisana proceduralnie w języku C i stanowi jednynie warstwę abstrakcji do sprzętu mikorprocesora. Biblioteka wspiera używanie mikroprocesorów \emph{BCM2835}, \emph{BCM2836} oraz  \emph{BCM2837}. \\*
                WiringPi implementuje m.in. : 
                \begin{itemize}
                    \item obsługę wejść i wyjść,
                    \item obsługę przerwań,
                    \item PWM,
                    \item SPI,
                    \item IIC,
                    \item wielowątkowość.
                \end{itemize}
                W projekcie wykorzystano jedynie obsługę PWM.
                
                \subsection{Oprogramowanie dodatkowe}
                \subsubsection{Logger}
                \subsubsection{Pomiar obciążenia systemu}
                
                \newpage
                
                \subsection{Opis scenariuszy programowych}
                    \subsubsection{Start modułu}
                        \begin{figure}[H]
                        \begin{center}
                            \includegraphics[width=0.7\textwidth]{startup.png}
                            \caption{Schemat blokowy startu modułu} \label{fig:starup}
                        \end{center}
                        \end{figure}
                Przedstawiony schemat blokowy jest zaimplementowany w postaci skryptu bash'owego uruchamianego bezpośrednio po starcie systemu operacyjnego. Decyduje on o trybie uruchomienia urządzenia, włącza odpowieni plik binarny i konfiguruje peryferia sprzętowe procesora.
                \newpage
                        
                    \subsubsection{Tryb serwisowy 1}
                        \begin{figure}[H]
                        \begin{center}
                            \includegraphics[width=0.4\textwidth]{t1.png}
                            \caption{Schemat blokowy trybu serwisowego 1} \label{fig:serT1}
                        \end{center}
                        \end{figure}
                        Osobny program służacy do testowania połączenia Raspberry Pi z modułem wykonawczym, nie wykorzystuje kodu źródłowego aplikacji użytkownika, jest napisany w taki sposób aby zminimalizować możliwość wystąpienia błędu w czasie działania.
                        \newpage
                    
                    \subsubsection{Tryb serwisowy 2}
                        \begin{figure}[H]
                        \begin{center}
                            \includegraphics[width=0.7\textwidth]{t2.png}
                            \caption{Schemat blokowy trybu serwisowego 2} \label{fig:serT2}
                        \end{center}
                        \end{figure}
                        Program służy do całościowego testowania modułu (dokładniejszy opis testu w sekcji 5.4.2). Jest on osobnym programem, który korzysta z logiki i implementacji wykorzystanych w aplikacji użytkownika.
                        
                        \newpage
                        
                    \subsubsection{Tryb serwisowy 3}
                        \begin{figure}[H]
                        \begin{center}
                            \includegraphics[width=0.25\textwidth]{t3.png}
                            \caption{Schemat blokowy trybu serwisowego 3} \label{fig:serT3}
                        \end{center}
                        \end{figure}
                        Program ten swoje działanie rozpoczyna od odczytanie pliku startowego z poprzedniego uruchomienia aplikacji klienckiej, wyświetla on następnie takie dane jak czas poprzedniego działania, wystąpione błędy, oprócz tego program wyświela na ekranie dotykowym, dane o chwilowym obciążeniu systemu.
                    
                        \newpage

\chapter{Wnioski i uwagi}
\thispagestyle{fancy}
  \cite{CleanCode,EffectiveModern,RpiBeginner}


% \listoffigures
% \listoftables
\bibliographystyle{plabbrv}

\addcontentsline{toc}{chapter}{Bibliografia} %utworzenie w spisie treści pozycji Bibliografia
\bibliography{bibliografia} % wstawia bibliografię korzystając z pliku bibliografia.bib - dotyczy BibTeXa, jeżeli nie korzystamy z BibTeXa należy użyć otoczenia thebibliography



\end{document}